--------------------------------------------------------------
--------------------------------------------------------------
--                                                          --
-- This VHDL file has been generated by the verilog2vhdl    --
-- tool.                                                    --
-- Contact help@edautils.com  for support/info.--
--                                                          --
--                                                          --
--------------------------------------------------------------
--------------------------------------------------------------
--
--
-- Assumptions: 
--         (1) All the parameters are of type INTEGER, and hence the translated generics are of this type
--
--
-- Generated by : apache on 10/27/21 2:02 PM
--
--
library ieee;
use ieee.std_logic_1164.all;
package vl2vh_common_pack is 
    type vl2vh_memory_type is      array  ( natural range <> , natural range <>  )  of std_logic ;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic; 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector; 
end package; 




package body vl2vh_common_pack is 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
end; 


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;
use work.vl2vh_common_pack.all;
entity vscpu is 
generic (
        VSCPU_A_WIDTH : INTEGER := 6 ;
        VSCPU_D_WIDTH : INTEGER := 8 ;
        MEMSIZE : INTEGER := 63 ;
        PC_STARTS_AT : INTEGER := 1 ;
        INSTR_add : INTEGER 1  downto 0  := 0 ;
        INSTR_and : INTEGER 1  downto 0  := 1 ;
        INSTR_jmp : INTEGER 1  downto 0  := 2 ;
        INSTR_inc : INTEGER 1  downto 0  := 3 ;
        ST_FETCH1 : INTEGER 5  downto 0  := 1 ;
        ST_FETCH2 : INTEGER 5  downto 0  := 2 ;
        ST_FETCH3 : INTEGER 5  downto 0  := 3 ;
        ST_ADD1 : INTEGER 5  downto 0  := 4 ;
        ST_ADD2 : INTEGER 5  downto 0  := 5 ;
        ST_AND1 : INTEGER 5  downto 0  := 6 ;
        ST_AND2 : INTEGER 5  downto 0  := 7 ;
        ST_JMP1 : INTEGER 5  downto 0  := 8 ;
        ST_INC1 : INTEGER 5  downto 0  := 9 ;
        ST_HALT : INTEGER 5  downto 0  := 63 
    );
     port (
        clock :  in std_logic;
        reset :  in std_logic;
        start :  in std_logic;
        write :  in std_logic;
        addr :  in std_logic_vector( ( VSCPU_A_WIDTH - 1  )  downto 0  );
        data :  in std_logic_vector( ( VSCPU_D_WIDTH - 1  )  downto 0  );
        status :  out std_logic
    );
end entity; 


architecture rtl of vscpu is 
    signal mem : vl2vh_memory_type( ( VSCPU_D_WIDTH - 1  )  downto 0 , 0  to ( MEMSIZE - 1  )  );
    signal read : std_logic;
    signal data_rd : std_logic_vector( ( VSCPU_D_WIDTH - 1  )  downto 0  );
    signal address : std_logic_vector( ( VSCPU_A_WIDTH - 1  )  downto 0  );
    signal AC_ff : std_logic_vector( 7  downto 0  );
    signal AR_ff : std_logic_vector( ( VSCPU_A_WIDTH - 1  )  downto 0  );
    signal PC_ff : std_logic_vector( ( VSCPU_A_WIDTH - 1  )  downto 0  );
    signal DR_ff : std_logic_vector( ( VSCPU_D_WIDTH - 1  )  downto 0  );
    signal IR_ff : std_logic_vector( 1  downto 0  );
    signal AC_ns : std_logic_vector( 7  downto 0  );
    signal AR_ns : std_logic_vector( ( VSCPU_A_WIDTH - 1  )  downto 0  );
    signal PC_ns : std_logic_vector( ( VSCPU_A_WIDTH - 1  )  downto 0  );
    signal DR_ns : std_logic_vector( ( VSCPU_D_WIDTH - 1  )  downto 0  );
    signal IR_ns : std_logic_vector( 1  downto 0  );
    signal stvar_ff : std_logic_vector( 5  downto 0  );
    signal stvar_ns : std_logic_vector( 5  downto 0  );
    signal i : INTEGER;
    begin 
        address <= vl2vh_ternary_func( ( ST_HALT = stvar_ff ) , addr, AR_ff );
        process 
        begin
            wait until ( clock'EVENT and ( clock = '1' )  ) ;
            if ( reset ) then 
                i <= 0 ;
                while ( ( i < ( MEMSIZE - 1  )  )  ) loop
                    mem(i) <= 0 ;
                    i <= ( i + 1  ) ;
                end loop;
            else 
                if ( ( write and (  not read )  )  ) then 
                    mem(address) <= data;
                end if;
            end if;
        end process;
        data_rd <= vl2vh_ternary_func( ( read and (  not write )  ) , mem(address), 'Z' );
        process 
        begin
            wait until ( clock'EVENT and ( clock = '1' )  ) ;
            if ( ( reset = '1' )  ) then 
                stvar_ff <= ST_HALT;
            else 
                if ( ( start = '1' )  ) then 
                    stvar_ff <= ST_FETCH1;
                else 
                    stvar_ff <= stvar_ns;
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( clock'EVENT and ( clock = '1' )  ) ;
            if ( ( reset = '1' )  ) then 
                AC_ff <= 0 ;
                PC_ff <= PC_STARTS_AT;
                AR_ff <= 0 ;
                IR_ff <= 0 ;
                DR_ff <= 0 ;
            else 
                AC_ff <= AC_ns;
                PC_ff <= PC_ns;
                AR_ff <= AR_ns;
                IR_ff <= IR_ns;
                DR_ff <= DR_ns;
            end if;
        end process;
        process 
        begin
            wait ;
            stvar_ns <= stvar_ff;
            case  ( stvar_ff ) is 
                when 
                    ST_HALT => 
                    stvar_ns <= ST_HALT;
                when 
                    ST_FETCH1 => 
                    stvar_ns <= ST_FETCH2;
                when 
                    ST_FETCH2 => 
                    stvar_ns <= ST_FETCH3;
                when 
                    ST_FETCH3 => 
                    case  ( IR_ff ) is 
                        when 
                            INSTR_add => 
                            stvar_ns <= ST_ADD1;
                        when 
                            INSTR_and => 
                            stvar_ns <= ST_AND1;
                        when 
                            INSTR_jmp => 
                            stvar_ns <= ST_JMP1;
                        when 
                            INSTR_inc => 
                            stvar_ns <= ST_INC1;
                    end case;
                when 
                    ST_ADD1 => 
                    stvar_ns <= ST_ADD2;
                when 
                    ST_AND1 => 
                    stvar_ns <= ST_AND2;
                when 
                    ST_JMP1 => 
                    stvar_ns <= ST_FETCH1;
                when 
                    ST_INC1 => 
                    stvar_ns <= ST_FETCH1;
                when 
                    ST_ADD2 => 
                    stvar_ns <= ST_FETCH1;
                when 
                    ST_AND2 => 
                    stvar_ns <= ST_FETCH1;
            end case;
        end process;
        process 
        begin
            wait ;
            if ( ( ( ( stvar_ff = ST_FETCH2 )  or ( stvar_ff = ST_ADD1 )  )  or ( stvar_ff = ST_AND1 )  )  ) then 
                read <= 1 ;
            else 
                read <= 0 ;
            end if;
        end process;
        process 
        begin
            wait ;
            AR_ns <= AR_ff;
            PC_ns <= PC_ff;
            DR_ns <= DR_ff;
            IR_ns <= IR_ff;
            AC_ns <= AC_ff;
            case  ( stvar_ff ) is 
                when 
                    ST_FETCH1 => 
                    AR_ns <= PC_ff;
                when 
                    ST_FETCH2 => 
                    PC_ns <= ( PC_ff + 1  ) ;
                    DR_ns <= data_rd;
                    IR_ns <= DR_ns(( VSCPU_D_WIDTH - 1  )  downto ( VSCPU_D_WIDTH - 2  ) );
                    AR_ns <= DR_ns(( VSCPU_D_WIDTH - 3  )  downto 0 );
                when 
                    ST_FETCH3 => 
                when 
                    ST_ADD1 => 
                    DR_ns <= data_rd;
                when 
                    ST_ADD2 => 
                    AC_ns <= ( AC_ff + DR_ff ) ;
                when 
                    ST_AND1 => 
                    DR_ns <= data_rd;
                when 
                    ST_AND2 => 
                    AC_ns <= ( AC_ff and DR_ff ) ;
                when 
                    ST_JMP1 => 
                    PC_ns <= DR_ff(( VSCPU_D_WIDTH - 3  )  downto 0 );
                when 
                    ST_INC1 => 
                    AC_ns <= ( AC_ff + 1  ) ;
                when 
                     others  => 
            end case;
        end process;
        process 
        begin
            wait until ( clock'EVENT and ( clock = '1' )  ) ;
            if ( ( stvar_ff = ST_FETCH1 )  ) then 
                report " -----> AC = 0x%xAC_ff";
            end if;
        end process;
        process 
        begin
            wait  on clock;
            report "CS: %g clk =%x rst =%x start =%x write =%x pc=%x cstate =%x $timeclockresetstartwritePC_ffstvar_ffac=%x ir=%x dr=%x ar=%x data_rd =%x read =%x address =%xAC_ffIR_ffDR_ffAR_ffdata_rdreadaddress";
        end process;
    end; 

